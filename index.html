<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation: Audio to Video Converter</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6;
            margin: 0 auto;
            max-width: 800px;
            padding: 2em;
            color: #333;
            background-color: #f9f9f9;
        }
        h1, h2 {
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }
        h1 {
            text-align: center;
        }
        hr {
            border: 0;
            height: 1px;
            background: #ddd;
            margin: 2em 0;
        }
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 2em auto;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        code {
            background-color: #ecf0f1;
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 1em;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 0.9em;
        }
        pre code {
            padding: 0;
            margin: 0;
            background-color: transparent;
        }
        ul {
            padding-left: 20px;
        }
        li {
            margin-bottom: 0.5em;
        }
        strong {
            color: #2980b9;
        }
    </style>
</head>
<body>

    <h1>Technical Documentation: Audio to Video Converter</h1>

    <p>This document provides a technical breakdown of the "Audio to Video Converter," a Python application built with <code>tkinter</code>. The application serves as a user-friendly graphical interface for the powerful command-line tool <strong>FFmpeg</strong>, allowing users to easily convert multiple audio files into videos by pairing them with a static image.</p>

    <img src="Screenshot 2025-09-21 112545.png" alt="Screenshot of the Audio to Video Converter application interface">

    <hr>

    <h2>Core Technologies ‚öôÔ∏è</h2>
    <p>The application is built entirely in Python and leverages several key libraries and modules to achieve its functionality:</p>
    <ul>
        <li><strong>Tkinter:</strong> This is Python's standard GUI (Graphical User Interface) library. It's used to create all the visual elements of the application, including the main window, buttons, listbox, labels, and progress bars. The <code>ttk</code> themed widgets are used for a more modern look and feel.</li>
        <li><strong>Subprocess:</strong> This module is essential for running and managing the external FFmpeg process. It allows the Python script to execute command-line operations, capture their output (<code>stdout</code> and <code>stderr</code>), and monitor their status.</li>
        <li><strong>Threading:</strong> To prevent the user interface from freezing during the time-consuming video conversion process, the core FFmpeg operations are run in a separate background thread. This ensures the application remains responsive, allowing the user to see real-time progress updates and even cancel the operation.</li>
        <li><strong>Queue:</strong> This module provides a thread-safe queue, which is used as a communication channel between the background conversion thread and the main GUI thread. Log messages generated by the FFmpeg process are placed into the queue by the background thread and safely retrieved by the main thread to be displayed in the logs window.</li>
        <li><strong>Imageio-ffmpeg:</strong> This helper library is used for a single, crucial purpose: to automatically locate the FFmpeg executable on the user's system. This removes the need for the user to manually configure the path to FFmpeg.</li>
        <li><strong>OS & Re:</strong> The <code>os</code> module is used for file system operations, like extracting filenames from full paths, while the <code>re</code> (regular expression) module is used to parse text output from FFmpeg to determine video duration and conversion progress.</li>
    </ul>

    <hr>

    <h2>Architecture and Workflow üèóÔ∏è</h2>
    <p>The application is encapsulated within a single class, <code>YouTubeAudioBatchConverter</code>, which manages the application's state, UI, and logic.</p>

    <h3>1. Initialization & UI Setup</h3>
    <p>When the application starts, the <code>__init__</code> constructor:</p>
    <ol>
        <li>Initializes the main <code>tkinter</code> window (<code>self.root</code>).</li>
        <li>Sets up a <code>ttk.Style</code> for the UI elements.</li>
        <li>Initializes state variables, such as <code>self.audio_files</code>, <code>self.image_file</code>, and <code>self.output_dir</code>.</li>
        <li>Calls <code>self.create_widgets()</code> to build the entire user interface as shown in the screenshot. The UI is logically divided into frames: a top toolbar, a file info section, a controls row, progress bars, and a logs console.</li>
        <li>Starts a recurring check of the <code>log_queue</code> via <code>self.process_log_queue</code>, allowing messages from other threads to be displayed in the UI.</li>
    </ol>

    <h3>2. User Interaction</h3>
    <p>The user interacts with the application through the buttons in the toolbar:</p>
    <ul>
        <li><strong>[+ Audio], [Image...], [Output...]</strong>: These buttons trigger <code>filedialog</code> prompts, allowing the user to select input files and an output directory. The selections are stored in the class variables and the UI labels are updated accordingly.</li>
        <li><strong>[‚àí Remove], [√ó Clear]</strong>: These buttons manage the list of audio files to be processed, modifying both the internal <code>self.audio_files</code> list and the visible <code>audio_listbox</code>.</li>
    </ul>

    <h3>3. The Conversion Process</h3>
    <p>This is the core logic of the application, handled by a background thread to keep the GUI responsive.</p>
    <ol>
        <li><strong>Start Conversion</strong>: Clicking the <strong>‚ñ∂ Start</strong> button calls the <code>start_conversion</code> method. This method first validates that an audio file, an image, and an output directory have all been selected. It then disables the "Start" button, enables the "Cancel" button, and launches the <code>run_batch_conversion</code> method in a new daemon thread.</li>
        <li><strong>Batch Processing</strong>: The <code>run_batch_conversion</code> method iterates through each audio file selected by the user. For each file, it constructs and executes a specific FFmpeg command.</li>
        <li><strong>The FFmpeg Command</strong>: The script programmatically builds the following command for each conversion:
            <pre><code>ffmpeg -y -i "audio_file.mp3" -loop 1 -i "image_file.png" -c:v libx264 -tune stillimage -c:a aac -b:a 192k -pix_fmt yuv420p -shortest -vf "scale=...:pad=..." "output_file.mp4"</code></pre>
            <ul>
                <li><code>-y</code>: Automatically overwrites the output file if it exists.</li>
                <li><code>-i "audio_file.mp3"</code>: Specifies the input audio file.</li>
                <li><code>-loop 1 -i "image_file.png"</code>: Specifies the input image and loops it indefinitely.</li>
                <li><code>-c:v libx264 -tune stillimage</code>: Uses the efficient H.264 video codec, optimized for static images.</li>
                <li><code>-c:a aac -b:a 192k</code>: Uses the AAC audio codec with a bitrate of 192 kbps.</li>
                <li><code>-pix_fmt yuv420p</code>: Sets the pixel format to ensure compatibility across most players and platforms.</li>
                <li><code>-shortest</code>: Ensures the video output duration matches the shorter of the inputs (in this case, the audio file).</li>
                <li><code>-vf "..."</code>: Applies a video filter to scale the image to fit within a 1920x1080 frame, adding black bars (padding) if necessary to maintain the aspect ratio.</li>
            </ul>
        </li>
        <li><strong>Execution and Progress Tracking</strong>:
            <ul>
                <li>Before running the main command, the <code>get_audio_duration</code> method runs a separate, quick <code>ffmpeg -i</code> command. It parses the command's text output with a regular expression to find the audio file's total duration.</li>
                <li>The main FFmpeg command is then executed using <code>subprocess.Popen</code>. This is crucial as it allows the script to read the command's output streams (<code>stdout</code> and <code>stderr</code>) in real-time.</li>
                <li>As FFmpeg processes the file, it prints progress updates to its <code>stderr</code> stream, which look like <code>time=00:01:23.45 ...</code>. The <code>run_ffmpeg</code> method reads these lines one by one.</li>
                <li>A regular expression (<code>time_re</code>) is used to extract the current timestamp from the progress line.</li>
                <li>This timestamp is converted to seconds and compared against the total duration to calculate a percentage progress.</li>
                <li>The <code>file_progress</code> bar is updated. <strong>Critically</strong>, this UI update is sent to the main thread using <code>self.root.after()</code>, as directly modifying <code>tkinter</code> widgets from a secondary thread is not safe.</li>
            </ul>
        </li>
    </ol>

    <h3>4. Logging and Completion</h3>
    <ul>
        <li><strong>Thread-Safe Logging</strong>: All output from the FFmpeg process (both progress and other information) is not written directly to the log window. Instead, the <code>log()</code> method places the message string into <code>self.log_queue</code>. The <code>process_log_queue</code> method, running on the main GUI thread, periodically checks this queue for new messages and safely inserts them into the <code>scrolledtext</code> widget. This prevents race conditions and ensures smooth UI updates.</li>
        <li><strong>Cancellation</strong>: If the user clicks <strong>‚èπ Cancel</strong>, the <code>self.cancelled</code> flag is set to <code>True</code>, and the <code>self.process.kill()</code> method immediately terminates the running FFmpeg process.</li>
        <li><strong>Completion</strong>: Once the loop finishes (or is cancelled), the UI buttons are returned to their original state. If the process completed successfully, a confirmation message is displayed.</li>
    </ul>

</body>
</html>
